package org.osehra.integration.http.handler;

import org.osehra.integration.core.error.ExceptionHandler;
import org.osehra.integration.core.error.ExceptionReportUtil;
import org.osehra.integration.core.error.HandlerException;
import org.osehra.integration.core.interceptor.InterceptorException;
import org.osehra.integration.core.service.ServiceInvocationException;
import org.osehra.integration.core.transformer.TransformerException;
import org.osehra.integration.http.HttpServiceInvocationException;
import org.osehra.integration.util.NullChecker;

import java.util.List;

import javax.ws.rs.core.Response;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.springframework.beans.factory.annotation.Required;

import com.sun.jersey.api.client.ClientResponse.Status;

public class ResponseExceptionHandler implements ExceptionHandler<Object> {

	private static final Log LOG = LogFactory.getLog(ResponseExceptionHandler.class);
	
	final String HTTPVERSIONTEXT = "HTTP/1.1";
	
	private List<Class<Exception>> reportExceptionClasses;
	
	/**
	 * This method receives an exception and transforms it into the outgoing 
	 * javax.ws.rs.core.Response instance, while logging the exception at the 
	 * 'error' log level.  If the exception is not handled here - because its 
	 * underlying cause's Exception type is not in the reportExceptionClasses List property 
	 * - then the received exception will be re-thrown inside an HandlerException instance.  
	 * The returned Response's message text will have the format of "HTTP/1.1 404 NOT FOUND" 
	 * appropriate to the exception received, be of type "text/plain", and have the 
	 * HTTP Status appropriate to the exception received.
	 * 
	 * @param message - the original message instance at the time of the exception throw
	 * @param ex - the exception thrown and being handled here
	 * @param componentName - text name of the component throwing the Exception - not used
	 * @param componentId - alphanumeric code identify the component throwing the Exception - not used
	 *  
	 * @return the Response containing the exception information for 
	 * the Consumer
	 */
	@Override
	public Object handleException(Object message, Exception ex, String componentName,
			String componentId) throws HandlerException {
		
		Response response = null;
		try {
			LOG.error(ex.getMessage(), ex);
			
			// Get the desired Exception, even if wrapped in the given Exception ex, if it exists in reportExceptionClasses
			// NOTE: There can only be one response generated by this loop since ex only has one Exception type
			for(Class<Exception> currentReportExceptionClass: this.reportExceptionClasses) {
				
				Throwable th = ExceptionReportUtil.getReportException(ex, currentReportExceptionClass);			
				Exception rootCauseException = (Exception)th;				
				
				if ((NullChecker.isEmpty(response)) && (rootCauseException instanceof HttpServiceInvocationException)) {
					
					HttpServiceInvocationException hsiEx = (HttpServiceInvocationException) rootCauseException;			
					
					int httpStatusCode = hsiEx.getErrorCode();						
					Status responseStatus = Status.fromStatusCode(httpStatusCode);					
					if(NullChecker.isNotEmpty(responseStatus)) {
						StringBuilder responseMessage = new StringBuilder(HTTPVERSIONTEXT).append(" ").append(responseStatus.getStatusCode()).append(" ").append(responseStatus.toString());
						response = Response.status(httpStatusCode).type("text/plain").entity(responseMessage.toString()).build();
					} else {
						StringBuilder responseMessage = new StringBuilder(HTTPVERSIONTEXT).append(" ").append(Status.INTERNAL_SERVER_ERROR.getStatusCode()).append(" ").append(Status.INTERNAL_SERVER_ERROR.toString());
						response = Response.status(Status.INTERNAL_SERVER_ERROR).type("text/plain").entity(responseMessage.toString()).build();
					}	
				} else if ((NullChecker.isEmpty(response)) && ( (rootCauseException instanceof ServiceInvocationException) || (rootCauseException instanceof TransformerException) || (rootCauseException instanceof InterceptorException))) {
					StringBuilder responseMessage = new StringBuilder(HTTPVERSIONTEXT).append(" ").append(Status.INTERNAL_SERVER_ERROR.getStatusCode()).append(" ").append(Status.INTERNAL_SERVER_ERROR.toString());
					response = Response.status(Status.INTERNAL_SERVER_ERROR).type("text/plain").entity(responseMessage.toString()).build();
				} else if ((NullChecker.isEmpty(response)) && (rootCauseException instanceof Exception)) {
					StringBuilder responseMessage = new StringBuilder(HTTPVERSIONTEXT).append(" ").append(Status.INTERNAL_SERVER_ERROR.getStatusCode()).append(" ").append(Status.INTERNAL_SERVER_ERROR.toString());
					response = Response.status(Status.INTERNAL_SERVER_ERROR).type("text/plain").entity(responseMessage.toString()).build();
				}
			}
			if(NullChecker.isEmpty(response)) {
				LOG.trace("the received Exception "+ex.getClass()+" was not handled in ResponseExceptionHandler.");
				throw ex;
			}
			return response;
		} catch(final Exception e) {
			throw new HandlerException(e);
		}	
	}	
	
	@Override
	public Object handleException(Object message, Exception ex)
			throws HandlerException {
		return this.handleException(message, ex, "", "");
	}
	
	@Required
	public void setReportExceptionClasses(
			List<Class<Exception>> reportExceptionClasses) {
		this.reportExceptionClasses = reportExceptionClasses;
	}

}
